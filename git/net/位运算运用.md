


## 一、权限设置
https://www.cnblogs.com/linzheng/archive/2010/10/18/1855166.html

第一步, 先建立一个枚举表示所有的权限管理操作，接下来是权限的运算等。

　　常用的位运算主要有与(&), 或(|)和非(~), 比如:

　　1 & 0 = 0, 1 | 0 = 1, ~1 = 0

　　在设计权限时, 我们可以把权限管理操作转换为C#位运算来处理.

　　第一步, 先建立一个枚举表示所有的权限管理操作:

　　[Flags]

　　public enum Permissions
　　{
　　Insert = 1,
　　Delete = 2,
　　Update = 4,
　　Query = 8
　　}
　　[Flags]表示该枚举可以支持C#位运算, 而枚举的每一项值, 我们用2的n次方来赋值, 这样表示成二进制时刚好是1 = 0001, 2 = 0010, 4 = 0100, 8 = 1000等, 每一位表示一种权限, 1表示有该权限, 0表示没有.

　　接下来是权限的运算:

　　1. 权限的加法, 使用与运算来实现. 我们知道, 0001 | 0100 = 0101, 这样就表示同时具有第一位和第三位的权限管理了, 枚举表示为:

　　Permissions per = Permissions.Insert | Permissions.Update

　　2. 权限的减法, 使用与运算+非运算来实现, 如上面要去掉Insert权限, 操作为:

　　Permissions per &= ~Permissions.Insert即是 0101 & ~0001 = 0101 & 1110 = 0100

　　3. 权限的判断, 使用与运算, 当判断用一用户是否具有该操作权限时, 要把用户的的权限与操作权限进行与运算, 如果得到的结果仍是操作权限管理, 则表示用户具有该权限:

　　Permissions per = Permissions.Insert | Permissions.Update;

　　if(per & PermissionsPermissions.Insert = Permissions.Insert)

　　{

　　//有操作权限

　　}

　　比较过程为 0101 & 0001 = 0001, 0001的0位用与C#位运算把其它位都置成0, 变成只比较1的这一位.



## 常用的位运算包括&（按位与）、|（按位或）、~（按位取反）、^（按位异或）、<<（左移）、>>（右移）。

&通常用于需要选择特定的数位的情况，因为任何一个数位和1相与得到的是其本身；
|通常用于要求尽可能保留1的情况，因为只要有1，或运算的结果一定是1；
~按位取反会将符号位一同取反，得到的还是一个有符号整数；
^常用于去除重复元素的情况，和“负负得正”这种情况比较类似；
<<和>>通常和上面4种位运算符搭配使用，不过要注意在Python中左移是不会发生溢出的，需要人为判断溢出

原文链接：https://blog.csdn.net/qq_16137569/article/details/82790378



链接：https://www.jianshu.com/p/78a984173985
```java
public class NewPermission {

    // 是否允许查询，二进制第1位，0表示否，1表示是
    public static final int ALLOW_SELECT = 1 << 0; // 0001

    // 是否允许新增，二进制第2位，0表示否，1表示是
    public static final int ALLOW_INSERT = 1 << 1; // 0010

    // 是否允许修改，二进制第3位，0表示否，1表示是
    public static final int ALLOW_UPDATE = 1 << 2; // 0100

    // 是否允许删除，二进制第4位，0表示否，1表示是
    public static final int ALLOW_DELETE = 1 << 3; // 1000

    // 存储目前的权限状态
    private int flag;

    /**
     * 重新设置权限
     */
    public void setPermission(int permission) {
        flag = permission;
    }

    /**
     * 添加一项或多项权限
     */
    public void enable(int permission) {
        flag |= permission;
    }

    /**
     * 移除一项或多项权限
     */
    public void disable(int permission) {
        flag &= ~permission;
    }

    /**
     * 是否拥有某项权限
     */
    public boolean isAllow(int permission) {
        return (flag & permission) == permission;
    }

    /**
     * 是否禁用了某些权限
     */
    public boolean isNotAllow(int permission) {
        return (flag & permission) == 0;
    }

    /**
     *  是否仅仅拥有某些权限
     */
    public boolean isOnlyAllow(int permission) {
        return flag == permission;
    }
}
public void enable(int permission) {
        flag |= permission;
    }
//添加多项权限：
permission.enable(NewPermission.ALLOW_INSERT  | NewPermission.ALLOW_UPDATE | NewPermission.ALLOW_DELETE);
```
以上代码中，用四个常量表示了每个二进制位代码的权限项。

ALLOW_SELECT = 1 << 0 转成二进制就是0001，二进制第一位表示Select权限。
ALLOW_INSERT = 1 << 1 转成二进制就是0010，二进制第二位表示Insert权限


## 1、判断奇偶
 public static boolean isOdd(int a) {
        return (a & 1) != 0;
    }
## 2、数据交换
    public static void swap(int a, int b){
        a^=b;
        b^=a;
        a^=b;
    }
## 3、求绝对值
    public static int abs(int x) {
        int y;
        y = x >> 31;
        return (x ^ y) - y;        //or: (x+y)^y
    }
## 4、byte与十六进制数的转换
转换原理
Java中byte每个字符是由8个bit组成的，而16进制中每个字符由4个bit组成的[16进制中最大为:0xF(15)转为二进制为：1111组成的4个bit]。所以我们可以把一个byte转换成两个16进制字符，即把高4位和低4位转换成相应的16进制字符，并组合这两个16进制字符串，从而得到byte的16进制字符串。同理，相反的转换也是将两个16进制字符转换成一个byte。
    public static String byteArrayToHexString(byte[] data) {
        StringBuilder sb = new StringBuilder(data.length * 2);
        for (byte b : data) {
            int v = b & 0xff;
            if (v < 16) {
                sb.append('0');
            }
            sb.append(Integer.toHexString(v));
        }
        return sb.toString();
    }

链接：https://www.jianshu.com/p/78a984173985